Development
===========

This document covers design and implementation details for Pyranha.


High Level Overview
-------------------

There are two major components to Pyranha, and multiple supporting pieces.
The first major component is called the "engine", and serves as the "back end"
of the application, managing connections to IRC servers.  The second major
component is the user interface, which displays channels to the user and
collects user input in the form of commands.  The engine and user interface
are executed in separate threads, and use asynchronous message passing to
communicate with each other.

Other components will include central configuration and state management, and
a simple plugin architecture for extending behaviors of both the engine and
the user interface.

### Message Passing

Each component contains a thread-safe message queue, where other components
can send asynchronous messages.  The receiving component will check the queue
periodically, and process any messages it finds.

Synchronous messages are not yet supported.

### Engine

The engine consists of two smaller pieces: a wrapper around the event-driven
irclib objects that processes events and sends messages to the user interface,
and a command processor that translates messages from the user interface into
method calls to irclib.

### User Interface

The user interface component uses a standard API, and is specifically designed
to be allow multiple implementations to be chosen from at startup.  This allows
Pyranha to more easily adapt to the environment in which it's being used; eg.
a textual curses interface when run on a terminal, a Gtk3 interface when run on
Gnome, or a PyObjC interface when run on Mac OSX.

The UI role has been intentionally restricted in functionality to make writing
platform-specific frontends easier; by default it only needs to display events
from the engine and send text commands from the user to the engine.  Any
functionality beyond that is not necessary for a complete experience.


Command Message Reference
-------------------------

Command messages are sent to the engine, and generally tell it to do something
that it wouldn't otherwise know to do, like sending chat messages to the server
or joining a new channel.  These are usually generated by the user interface at
the request of the user.

Command messages are three-tuples, consisting of the command name, network
name, and parameters to the command.  The network name can be `*` to send the
command to all connected networks, or `None` for commands that are not network
specific.  The parameters can be None, a single string, or an iterable object.

*   `start`

    This tells the engine to initialize itself, and connect to any networks
    that are configured to connect automatically.  This is triggered by the
    user interface after it is ready to begin accepting events from the engine.

*   `stop`

    This command tells the engine to disconnect all connections and stop
    itself.  This is triggered by the user interface when the user has
    requested the application to halt and exit.  When the engine has finished,
    it will emit the `stopped` message back to the UI before exiting.

*   `raw <network> <message:string>`

    This tells the engine to send a raw command to the IRC server, without
    modification, inspection, or interpretation.

*   `send <network> (<target:string>, <message:string>)`

    This command tells the engine to interpret a message from the user, and
    send it to the given network and target.  Interpretting the message means
    the engine will inspect the message for certain patterns, and modify or
    reroute the message as appropriate.

    The following patterns should be supported by the engine:

    *   `/me <action>`
    *   `/msg <nick> <message>`
    *   `/join <channel>`
    *   `/part`


Event Message Reference
-----------------------

Event messages are sent to the user interface, and generally inform it of
things that happened on the servers, like chat messages from a channel or users
that have joined a channel.

Event messages are three-tuples, consisting of the event type, network name,
and message content.  The network name can be `None` for events that are not
network specific.  The message content can be `None`, a single string, an
iterable object, or a dictionary.

*   `stopped`

    This event informs the user interface that the engine has stopped after
    receiving a `stop` command.

*   `print [network] <string>`

    This event represents a message from the engine directed towards the user.
    It should be displayed either in the appropriate network status window, or
    a dedicated status location if the network is `None`.

*   `debug [network] <string>`

    Similar to the `print` event, except this message should only be displayed
    to the user if they have explicitly enabled debug output from the program.
